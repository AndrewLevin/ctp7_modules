<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CTP7_MODULES: RPCsvc Module Development Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CTP7_MODULES
   </div>
   <div id="projectbrief">CTP7 modules for Zynq CPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RPCsvc Module Development Package </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This package contains everything required to build modules for the CTP7 RPC service. This document covers the structure of RPC modules as well as how to build them and install them on a CTP7. It also includes some <a href="#important-notes--caveats">important points</a> to be aware of when using this package.</p>
<h2>Considerations for Module Design</h2>
<ol type="1">
<li><p class="startli">Each client connection runs in its own process.</p>
<p class="startli">The implication of this is that it is not possible to use the pthread_mutex functions for locking or mutual exclusion. Use the provided tools in <a class="el" href="LockTools_8h_source.html">LockTools.h</a> instead.</p>
</li>
<li>The <a href="#module_version_key">module_version_key</a> described below should be kept up to date to prevent confusion or disruption when incompatible changes are made or modules are updated on the card. This allows client software to ensure that it will always receive the expected responses from the module.</li>
<li>While a request is being made to your module, the client application calling you is generally blocked. It is generally preferable to split up long slow operations such as tests or data aquisition into multiple calls where possible, with one call doing setup and another call retrieving collected data.</li>
</ol>
<h2>General Structure of a RPC module</h2>
<p>An RPC module consists of any number of RPC methods, and an initialization function and set of module specific data.</p>
<h3>RPC Methods</h3>
<p>RPC methods are defined as functions which take a <code>RPCMsg</code> request and <code>RPCMsg</code> response as parameters. These provide access to input and output data for the RPC request that the function services. Methods such as <code>get_word</code> and <code>set_word</code> can be used to access the data in these objects. Please review <code>RPCMsg.h</code> for a list of available data access methods, or reference <code>rpctest.cpp</code> for a full test case.</p>
<p>Errors should be reported as a response body field which is checked for on by the RPC client.</p>
<p>```cpp void mread(const RPCMsg *request, RPCMsg *response) { uint32_t count = request-&gt;get_word("count"); uint32_t addr = request-&gt;get_word("address"); uint32_t data[count];</p>
<p>if (memsvc_read(memsvc, addr, count, data) == 0) { response-&gt;set_word_array("data", data, count); } else { response-&gt;set_string("error", memsvc_get_last_error(memsvc)); LOGGER-&gt;log_message(LogManager::INFO, stdsprintf("read memsvc error: %s", memsvc_get_last_error(memsvc))); } } ```</p>
<h3>Logging</h3>
<p>The RPC server provides a logging facility to be used in RPC modules, which is configured to send their output to the standard unix syslog facility. See the <em>Network Configuration</em> document for more information on how this log data is handled.</p>
<p>There is a global LOGGER object accessible to modules to record log messages. It has two primary functions that are relevant to module developers: <code>log_message</code> and <code>indicate_activity</code>.</p>
<h4>log_message</h4>
<p><code>log_message</code> requires a <code>LogLevel</code> and a string containing the message to be logged:</p>
<p>```cpp LOGGER-&gt;log_message(LogManager::DEBUG, message); ```</p>
<h5>Log Levels</h5>
<p>The log levels used by the rpc service are taken from RCC5424 (Syslog). They are listed in decreasing order of severity below.</p>
<table class="doxtable">
<tr>
<th>Log Level </th><th>Meaning  </th></tr>
<tr>
<td>EMERGENCY </td><td>System is unusable </td></tr>
<tr>
<td>ALERT </td><td>Action must be taken immediately </td></tr>
<tr>
<td>CRITICAL </td><td>Critical conditions </td></tr>
<tr>
<td>ERROR </td><td>Error conditions </td></tr>
<tr>
<td>WARNING </td><td>Warning conditions </td></tr>
<tr>
<td>NOTICE </td><td>Normal but significant condition </td></tr>
<tr>
<td>INFO </td><td>Informational messages </td></tr>
<tr>
<td>DEBUG </td><td>Debug-level messages </td></tr>
</table>
<p>The majority of your meaningful informational messages should be output as <code>NOTICE</code>.</p>
<p>The majority of your normally insignificant informational messages should be output as <code>INFO</code>.</p>
<p>The majority of debug or generally irrelevant messages should be output as <code>DEBUG</code>.</p>
<h4>indicate_activity</h4>
<p><code>indicate_activity</code> requires no parameters and will trigger a flash on the front panel activity indicator LED. The color of this flash is determined by the module parameter <code>module_activity_color</code>. See below for more details.</p>
<p>```cpp LOGGER-&gt;indicate_activity(); ```</p>
<h3>Module Specific Data &amp; Initialization</h3>
<p>Each module requires a given set of module specific data and an initialization function which will be called at module load to initialize any necessary resources and register all provided functions with the RPC service infrastructure. Note that this section must be defined as <code>extern "C"</code> for proper linking.</p>
<p>```cpp extern "C" { const char *module_version_key = "memory v1.0.0"; int module_activity_color = 0; void module_init(ModuleManager *modmgr) { if (memsvc_open(&amp;memsvc) != 0) { LOGGER-&gt;log_message(LogManager::ERROR, stdsprintf("Unable to connect to memory service: %s", memsvc_get_last_error(memsvc))); LOGGER-&gt;log_message(LogManager::ERROR, "Unable to load module"); return; // Do not register our functions, we depend on memsvc. } modmgr-&gt;register_method("memory", "read", mread); modmgr-&gt;register_method("memory", "write", mwrite); } } ```</p>
<h4>Module Specific Data</h4>
<h5>module_version_key</h5>
<p>All modules contain a <code>module_version_key</code> string, which must be supplied by the client when the module is loaded.</p>
<p>This value should be unique across all modules and versions. You should keep this value up to date as you make changes to a module to prevent confusion in the event that the wrong module version is loaded on a particular card or client software expects different behavior from the module.</p>
<h5>module_activity_color</h5>
<p>All modules contain a <code>module_activity_color</code> int which determines the color of LED activity indicator flashes for that module. Any module is free to use the value '0' which will not produce any activity indication.</p>
<p><em>Please request the assignment of a specific value for your module.</em> The valid range of values is 0-8.</p>
<h4>Initialization Function</h4>
<p>All modules contain an initialization function, <code>void module_init(<a class="el" href="classModuleManager.html">ModuleManager</a> *modmgr)</code>. This function is called when the module is loaded by the client for the first time. It can be used to do any static initialization required, and is expected to register the RPC methods provided by the module so that they can be called.</p>
<p>Methods are registered with a call to ```cpp modmgr-&gt;register_module("module_name", "method_name", method_function); ``` and are subsequently made available for clients to execute.</p>
<h2>Installing and Using Modules</h2>
<h3>Building Modules</h3>
<p>Modules may be built using the Makefile provided in this package. Note that you will likely need to update the <code>PETA_STAGE</code> variable to point to an appropriate stage directory containing the relevant headers and libraries. Once this has been set up, you should simply be able to run <code>make</code> and all modules present in the module development package directory will be compiled.</p>
<h3>Installing Modules</h3>
<p>To install your module on a CTP7, simply compile it and place it in <code>/mnt/persistent/rpcmodules</code>. It will automatically be loadable by and available to any newly opened rpcsvc client connections. Updates are handled in the same manner. When a client sends a request to load a module for the first time, the version present on the card at that moment will be used for that session.</p>
<h2>Important Notes &amp; Caveats</h2>
<ol type="1">
<li>Do not edit or replace modules provided by the core linux build. They will be reinstalled at card startup, overwriting your changes. Your own non-system modules however will remain on the persistent filesystem as normal between reboots.</li>
<li><p class="startli">You do not need to and should not ever restart the rpcsvc dameon. Other services are also depending on it as well.</p>
<p class="startli">Closing your client connection will result the termination of the subprocess serving your client, and you will receive a fresh subprocess upon reconnection. This should handle any situation involving an rpcsvc restart.</p>
</li>
<li>The files provided as a part of this package are a part of the rpcsvc project and may be updated in the future. Please do <em>not</em> make local modifications to them, as having divergent sources <em>will</em> cause trouble in the future. Instead, request that any needed changes be made to the main project source. Please review the file <code>RPCSVC_MANIFEST</code> for details on this package including version information and a list of included files that originate from the rpcsvc core project. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
